bitmaps = {
	{0,1,1,1,0,  --0L1 
	 1,0,0,0,1,
	 1,0,0,0,1,
	 1,0,0,0,1,
	 1,0,0,0,1,
     0,1,1,1,0},
	 
    {0,1,0,0,0, --0M1
     1,0,1,0,0,
     1,0,1,0,0,
     0,1,0,0,0,
     0,0,0,0,0,
     0,0,0,0,0},
	   
    {0,0,1,0,0, --0M2
     0,1,0,1,0,
     0,1,0,1,0,
     0,0,1,0,0,
     0,0,0,0,0,
     0,0,0,0,0},
	   
    {0,0,0,1,0, --0M3
     0,0,1,0,1,
     0,0,1,0,1,
     0,0,0,1,0,
     0,0,0,0,0,
     0,0,0,0,0},
	   
    {0,0,0,0,0, --0M4
     0,1,0,0,0,
     1,0,1,0,0,
     1,0,1,0,0,
     0,1,0,0,0,
     0,0,0,0,0},
	   
    {0,0,0,0,0, --0M5
     0,0,1,0,0,
     0,1,0,1,0,
     0,1,0,1,0,
     0,0,1,0,0,
     0,0,0,0,0},
	   
    {0,0,0,0,0, --0M6
     0,0,0,1,0,
     0,0,1,0,1,
     0,0,1,0,1,
     0,0,0,1,0,
     0,0,0,0,0},
	   
    {0,0,0,0,0, --0M7
     0,0,0,0,0,
     0,1,0,0,0,
     1,0,1,0,0,
     1,0,1,0,0,
     0,1,0,0,0},
	      
	{0,0,0,0,0, --0M8
     0,0,0,0,0,
     0,0,1,0,0,
     0,1,0,1,0,
     0,1,0,1,0,
     0,0,1,0,0},
	   
    {0,0,0,0,0, --0M9
     0,0,0,0,0,
     0,0,0,1,0,
     0,0,1,0,1,
     0,0,1,0,1,
     0,0,0,1,0},
   
    {0,1,0,0,0, --0S1
     1,0,1,0,0,
     0,1,0,0,0,
     0,0,0,0,0,
     0,0,0,0,0,
     0,0,0,0,0},
   
    {0,0,1,0,0, --0S2
     0,1,0,1,0,
     0,0,1,0,0,
     0,0,0,0,0,
     0,0,0,0,0,
     0,0,0,0,0},
	  
    {0,0,0,1,0, --0S3
     0,0,1,0,1,
     0,0,0,1,0,
     0,0,0,0,0,
     0,0,0,0,0,
     0,0,0,0,0},
	  
    {0,0,0,0,0, --0S4
     0,1,0,0,0,
     1,0,1,0,0,
     0,1,0,0,0,
     0,0,0,0,0,
     0,0,0,0,0},
	  
    {0,0,0,0,0, --0S5
     0,0,1,0,0,
     0,1,0,1,0,
     0,0,1,0,0,
     0,0,0,0,0,
     0,0,0,0,0},
	   
    {0,0,0,0,0, --0S6
     0,0,0,1,0,
     0,0,1,0,1,
     0,0,0,1,0,
     0,0,0,0,0,
     0,0,0,0,0},
	  
    {0,0,0,0,0, --0S7
     0,0,0,0,0,
     0,1,0,0,0,
     1,0,1,0,0,
     0,1,0,0,0,
     0,0,0,0,0},
	  
    {0,0,0,0,0, --0S8
     0,0,0,0,0,
     0,0,1,0,0,
     0,1,0,1,0,
     0,0,1,0,0,
     0,0,0,0,0},
	  
    {0,0,0,0,0, --0S9
     0,0,0,0,0,
     0,0,0,1,0,
     0,0,1,0,1,
     0,0,0,1,0,
     0,0,0,0,0},
	  
    {0,0,0,0,0, --0S10
     0,0,0,0,0,
     0,0,0,0,0,
     0,1,0,0,0,
     1,0,1,0,0,
     0,1,0,0,0},
	  
    {0,0,0,0,0, --0S11
     0,0,0,0,0,
     0,0,0,0,0,
     0,0,1,0,0,
     0,1,0,1,0,
     0,0,1,0,0},
	  
    {0,0,0,0,0, --0S12
     0,0,0,0,0,
     0,0,0,0,0,
     0,0,0,1,0,
     0,0,1,0,1,
     0,0,0,1,0},
	 
	{0,1,0,0,0, --1L1
	 1,1,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0,
	 1,1,1,0,0},
	
	{0,0,1,0,0, --1L2
	 0,1,1,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,1,1,1,0},
	
	{0,0,0,1,0, --1L3
	 0,0,1,1,0,
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,1,1,1},
	 	 
	{0,1,0,0,0, --1M1
	 1,1,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,0,0,0,0},
	 
	{0,0,1,0,0, --1M2
	 0,1,1,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,0,0,0},
	 
	{0,0,0,1,0, --1M3
	 0,0,1,1,0,
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,0,0,0},
	 
	{0,0,0,0,1, --1M4
	 0,0,0,1,1,
	 0,0,0,0,1,
	 0,0,0,0,1,
	 0,0,0,0,1,
	 0,0,0,0,0},
	 
	{0,0,0,0,0, --1M5
	 0,1,0,0,0,
	 1,1,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0},
	 
	{0,0,0,0,0, --1M6
	 0,0,1,0,0,
	 0,1,1,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0},
	 
	{0,0,0,0,0, --1M7
     0,0,0,1,0,
     0,0,1,1,0,
     0,0,0,1,0,
     0,0,0,1,0,
     0,0,0,1,0},
	 
    {0,0,0,0,0, --1M8
     0,0,0,0,1,
     0,0,0,1,1,
     0,0,0,0,1,
     0,0,0,0,1,
     0,0,0,0,1},
	 
	{1,0,0,0,0, --1S1
	 1,0,0,0,0,
	 1,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	 
	{0,1,0,0,0, --1S2
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,1,0,0, --1S3 
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,1,0, --1S4 
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,1, --1S5 
	 0,0,0,0,1,
	 0,0,0,0,1,
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S6 
	 1,0,0,0,0,
	 1,0,0,0,0,
	 1,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S7 
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S8 
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S9 
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S10 
	 0,0,0,0,1,
	 0,0,0,0,1,
	 0,0,0,0,1,
	 0,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S11 
	 0,0,0,0,0,
	 1,0,0,0,0,
	 1,0,0,0,0,
	 1,0,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S12 
	 0,0,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S13 
	 0,0,0,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S14 
	 0,0,0,0,0,
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S15 
	 0,0,0,0,0,
	 0,0,0,0,1,
	 0,0,0,0,1,
	 0,0,0,0,1,
	 0,0,0,0,0},
	
	{0,0,0,0,0, --1S16 
	 0,0,0,0,0,
	 0,0,0,0,0,
	 1,0,0,0,0,
	 1,0,0,0,0,
	 1,0,0,0,0},
	
	{0,0,0,0,0, --1S17 
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0,
	 0,1,0,0,0},
	
	{0,0,0,0,0, --1S18 
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0,
	 0,0,1,0,0},
	
	{0,0,0,0,0, --1S19 
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,1,0,
	 0,0,0,1,0,
	 0,0,0,1,0},
	
	{0,0,0,0,0, --1S20 
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,1,
	 0,0,0,0,1,
	 0,0,0,0,1},
	
	 
	{0,1,1,0,0, --2L1
	 1,0,0,1,0,
	 0,0,0,1,0,
	 0,0,1,0,0,
	 0,1,0,0,0,
	 1,1,1,1,0},
	
	{0,0,1,1,0, --2L2
	 0,1,0,0,1,
	 0,0,0,0,1,
	 0,0,0,1,0,
	 0,0,1,0,0,
	 0,1,1,1,1},
	
	{0,1,0,0,0, --2M1
	 1,0,1,0,0,
	 0,0,1,0,0,
	 0,1,0,0,0,
	 0,1,1,0,0,
	 0,0,0,0,0},
	 
	{0,0,1,0,0, --2M2
	 0,1,0,1,0,
	 0,0,0,1,0,
	 0,0,1,0,0,
	 0,0,1,1,0,
	 0,0,0,0,0},
	 
	{0,0,0,1,0, --2M3
	 0,0,1,0,1,
	 0,0,0,0,1,
	 0,0,0,1,0,
	 0,0,0,1,1,
	 0,0,0,0,0},
	 
	{0,0,0,0,0, --2M4
	 0,1,0,0,0,
	 1,0,1,0,0,
	 0,0,1,0,0,
	 0,1,0,0,0,
	 0,1,1,0,0},
	 
	{0,0,0,0,0, --2M5
	 0,0,1,0,0,
	 0,1,0,1,0,
	 0,0,0,1,0,
	 0,0,1,0,0,
	 0,0,1,1,0},
	
	{0,0,0,0,0, --2M6
	 0,0,0,1,0,
	 0,0,1,0,1,
	 0,0,0,0,1,
	 0,0,0,1,0,
	 0,0,0,1,1},
	 
	{1,1,0,0,0, --2S1
	 0,1,0,0,0,
	 0,1,1,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	 
	{0,1,1,0,0, --2S2
	 0,0,1,0,0,
	 0,0,1,1,0,
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	 
	{0,0,1,1,0, --2S3
	 0,0,0,1,0,
	 0,0,0,1,1,
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	 
	{0,0,0,0,0, --2S4
	 1,1,0,0,0,
	 0,1,0,0,0,
	 0,1,1,0,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	 
	{0,0,0,0,0, --2S5
	 0,1,1,0,0,
	 0,0,1,0,0,
	 0,0,1,1,0,
	 0,0,0,0,0,
	 0,0,0,0,0},
	 
	{0,0,0,0,0, --2S6
	 0,0,1,1,0,
	 0,0,0,1,0,
	 0,0,0,1,1,
	 0,0,0,0,0,
	 0,0,0,0,0},
	 
	{0,0,0,0,0, --2S7
	 0,0,0,0,0,
	 1,1,0,0,0,
	 0,1,0,0,0,
	 0,1,1,0,0,
	 0,0,0,0,0},
	 
	{0,0,0,0,0, --2S8
	 0,0,0,0,0,
	 0,1,1,0,0,
	 0,0,1,0,0,
	 0,0,1,1,0,
	 0,0,0,0,0},
	 
	{0,0,0,0,0, --2S9
	 0,0,0,0,0,
	 0,0,1,1,0,
	 0,0,0,1,0,
	 0,0,0,1,1,
	 0,0,0,0,0},
	 
	{0,0,0,0,0, --2S10
	 0,0,0,0,0,
	 0,0,0,0,0,
	 1,1,0,0,0,
	 0,1,0,0,0,
	 0,1,1,0,0},
	 
	{0,0,0,0,0, --2S11
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,1,1,0,0,
	 0,0,1,0,0,
	 0,0,1,1,0},
	 
	{0,0,0,0,0, --2S12
	 0,0,0,0,0,
	 0,0,0,0,0,
	 0,0,1,1,0,
	 0,0,0,1,0,
	 0,0,0,1,1}
}
corela = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2}
bitmap = {}
function bitmap.display(bm)-- Afficher les bitmaps
	local chr = {string.char(219), string.char(196), string.char(179), string.char(218),string.char(191),string.char(192),string.char(217)} -- Caractères ascii pour dessiner les contours
	print(chr[4]..chr[2]..chr[2]..chr[2]..chr[2]..chr[2]..chr[5]) -- Afficher la première ligne de contour avec les caractères ascii définis précédemment
	for n=0,5 do -- n représente le nombre de lignes (dans ce cas, il y'a six lignes)
		io.write(chr[3]) -- Afficher le contour du bitmap (le contour de droite)
		for i=1,5 do -- i c'est le nombre de colonnes
			if bm[5*n+i] == 1 then -- Chaque pixel a un numéro particulier: par exemple, le premier pixel de la deuxième ligne a pour numéro 6 (5*1+1). Si elle vaut 1, un bloc noir s'affiche 
				io.write(chr[1]) -- Afficher le caractère ascii 219 (bloc noir) pour ensuite représenter correctement le bitmap
			else
				io.write(" ") -- Afficher un vide
			end
		end
		io.write(chr[3]) -- de la ligne 1 à 5 tracer les contours du bitmap (le contour de gauche)
		io.write("\n") -- Sauter une ligne
	end
	print(chr[6]..chr[2]..chr[2]..chr[2]..chr[2]..chr[2]..chr[7]) -- Afficher la dernière ligne de contour avec les caractères ascii définis précédemment
end

bit2 = {} -- Reconnaissance du Bitmap
function bit2.tobin(dec) -- Convertir les corrélations en binaire
	if dec == 0 then -- Si le cerveau aperçoit n'importe quel bitmap O, il affiche 0,0
		return 0, 0
	elseif dec == 1 then
		return 0, 1  -- Si le cerveau apercoit n'importe quel Bitmap 1, il affiche 0,1
	elseif dec == 2 then
		return 1, 0  -- Si le cerveau apercoit n'importe quel Bitmap 1, il affiche 1,0
	elseif dec == 3 then -- Il ne risque jamais d'avoir une image représentant un 3 donc le cerveau artificiel ne va jamais afficher 1,1
		return 1, 1
	else
		error("Value must be in range [0,3]") -- Si on donne au cerveau une image différente de 0 à 3, le cerveau affiche "erreur"
	end
end


os.execute("TITLE ENET TEST") -- Renommer le titre de l'invite de commandes
for i=1, #corela do -- de 1 jusqu'au au nombre de corrélations ( Ca nous permettra d'afficher par la suite toutes les bitmaps)
	os.execute("CLS") -- Si jamais on écrit CLS à la fn du programme, tout est effacé
	print("ENET TEST") -- Afficher ENET Test
	print("par Aymane GHANAM, Edgar DESNOS et Rodolphe VALICON") -- Afficher les noms
	bitmap.display(bitmaps[i])-- pour afficher toutes les bitmaps
	print("Bitmap n"..string.char(248)..i) -- cette ligne permet d'afficher le numéro du bitmap (le string char c'est pour afficher le petit rond avec le numéro et .. veut dire coller les mots)
	print("Image represents a "..corela[i]) -- Le cerveau va sortir "l'image représente 0,1 ou 2". La corrélation est nécessaire puisqu'il y'a plusieurs types de nombres
	print("ENET expected value: "..table.pack(bit2.tobin(corela[i]+1))[1]..table.pack(bit2.tobin(corela[i]+1))[2])
	print("ENET output value: ".. 0 .. 0) -- à modifier -- 00 si ca le reconnait pas 
	io.read()
end
print("END OF TEST")

--Class eneurone
eneurone = {n=0, p={},x={},s=0,y=false}
eneurone.__index = eneurone -- enregister le nombre "eneurone"

function eneurone.new(s) --Constructeur
	--Test de validité des variables
	--[[if n < 1 then  --Test du nombre d'entrée (qui doit être >=1)
		return false
	elseif s<=0 then --Test de la valeur du seuil ( qui doit être >0)
		return false
	elseif #p ~= n then -- Test de la longueur de la table de ponderation
		return false
	end
	for i=1,n do
		if p[i] <= 0 then --Test de la valeur de chaque poids ( qui doit être > 0)		
			return false 
		end
	end]]--
	--Création et configuration de l'objet	
	local self = setmetatable({}, eneurone)
	self.n = 0
	self.p = {}
	self.s = s
	self.y = 0 -- Chauqe neurone est etteint au début
	self.c = {} 
	self.x = {} 
	--for i=1,n do
		-- table.insert(self.x,false)
	-- end
	return self
end
function eneurone.addinput(self,co,n,pd) ???????????????????????????????????
	self.n = self.n + 1
	table.insert(self.x, false)
	table.insert(self.c,{c,n})
	table.insert(self.p,pd)
end
function eneurone.update(self) -- Met à Jour la sortie du neurone en fontion de ses entrées et de son seuil
	local sum = 0
	for i=1,self.n do -- Pour chaque neurone
		if self.x[i] then -- Pour chaque entrée x
			sum = sum + self.p[i] -- Ces deux dernières lignes permettent de calculer la pondération de chaque entrée
		end
	end
	if sum>=self.s then -- Si la pondération est supérieur au seuil
		self.y = true -- Afficher Vrai
	else
		self.y = false -- Afficher Faux
	end
end

function eneurone.process(res,vinit) ?????????????????????????????????? --Met en marche tout le réseau de neurone simule le réseau 
	for ch=1, #res do 
		for ne=1, #res[ch] do
			for inp=1, #res[ch][ne] do
				if (res[ch][ne][inp].c[inp][1] ~= nil) or (res[ch][ne][inp][2] ~= nil) then 
					res[ch][ne][inp] = res[res[ch][ne][inp].c[inp][1]][res[ch][ne][inp].c[inp][2]].y
				end
			end
			res[ch][ne]:update()
		end
	end
end

--Trainer
trainer = {}
function trainer.init() -- Initialisation du trainer
	trainer.res = {} -- Tableau qui va contenir tout le réseau de neurones
	trainer.lis = 0 -- Nombres de liaisons
	trainer.n = 0 -- Nombres de neurones
	trainer.cycles = 0 -- Nombre de cycles d'entrainement
	trainer.err = 100 -- Marge d'erreur
end

function trainer.generate(template) -- générer tout le réseau de neurones et créer toutes les couches
	if template == "pyramide_img" then
		--Génération des couches
		local nc = 30 -- Nombre de neurones de la 1ère couche
		local cc = 0 -- Nombre de couches
		for i=1,15 do -- pour la couche 1 à 15 (i est le truc par défaut, pour la première à la dernière couche)
			table.insert(trainer.res, {}) -- insérer dans un tableau une valeur
			for n=1,nc do -- du 1er au 30ème neurone de la première couche
				table.insert(trainer.res[i],eneurone.new(1)) -- les neurones ont un seuil de 1
				trainer.n = trainer.n + 1 -- Créer un nouveau neurone
				if i==1 then -- cette ligne veut dire à la 1ère couche ( en gros, ce if permet la création des liaisons)
					trainer.res[#trainer.res][#trainer.res[i]]:addinput(nil,nil,0) -- La première couche n'a pas de liaisons antérieurs (pas de liasions avant les neurones de la première couche)
					inp = inp + 1 -- Nombre de liaisons augmente de 1
				else
					for _,k in pairs(trainer.res[i-1]) do -- pour chaque valeur et clé qu'il y a dans la table  
						trainer.res[#trainer.res][#trainer.res[i]]:addinput(i-1,k,0) -- -- ajoute au neurone les sorties des neurones précédents
						inp = inp + 1 -- Nombre de liasons augmente de 1
					end
				end
			end
			nc = nc - 2 -- le nombre de neurones diminue par deux dans chaque couche
			cc = cc + 1 -- à chaque fois, on ajoute une couche
		end
		print("Generated "..trainer.n.." e-neurones, on "..cc.." layers.") -- afficher le nombre de neurones
		print("Created "..inp.." bonds.") -- afficher le nombre de liaisons
	end
end



trainer.init()
trainer.generate("pyramide_img")
trainer.train() -- répète cycle les entrainements

function trainer.cycle(data) --Un cycle d'entrainement

end

function trainer.train(data) -- cycle d'entrainement 
	print("Entrainement commencé.")
	while trainer.err > 0.05 do
		trainer.cycles = trainer.cycles + 1 -- ajouter un cycle d'entrainement à chauqe fois
		trainer.cycle(data)
	end
	print("Entrainement terminé!")
end 

